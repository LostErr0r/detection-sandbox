########## INPUT ##########

input {
  beats {
    port => 5044          # именно этот порт будет использовать Filebeat
  }
}

########## FILTER ##########

filter {
  ################ ACCESS.LOG* ################
if [log_type] == "juice_access" {
  grok {
    match => {
      "message" => [
        # 1) сначала пробуем стандартный COMBINEDAPACHELOG
        #    но переопределяем имя поля для User-Agent
        '%{IPORHOST:clientip} %{NOTSPACE:ident} %{NOTSPACE:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}" %{NUMBER:response} (?:%{NUMBER:bytes}|-) "%{DATA:referrer}" "%{DATA:http_user_agent}"',

        # 2) запасной вариант, если статус/байты = "-"
        '%{IPORHOST:clientip} %{NOTSPACE:ident} %{NOTSPACE:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}" (?:%{NUMBER:response}|-) (?:%{NUMBER:bytes}|-) "%{DATA:referrer}" "%{DATA:http_user_agent}"'
      ]
    }
    tag_on_failure => [ "_grokparsefailure_access" ]
  }

    mutate {
      remove_field => [
        "message",        # если не нужен сырой лог
        "@version",       # служебное поле logstash
        "ecs",            # метаданные ECS
        "input",          # блок input.*
        "host",           # блок host.*
        "log",            # путь файла и offset
        "agent"           # метаданные filebeat, если не нужны
      ]
    }

  date {
    match => [ "timestamp" , "dd/MMM/YYYY:HH:mm:ss Z" ]
    target => "@timestamp"
    tag_on_failure => [ "_dateparsefailure_access" ]
  }

  # ВАЖНО: теперь разбираем именно http_user_agent, а не agent
  useragent {
    source => "http_user_agent"
    target => "useragent"
  }

  mutate {
    add_field => { "[@metadata][target_index]" => "juice-shop-access" }
  }
}

  ################ SYSTEM AUDITD ################
  else if [log_type] == "system_audit" {

    #
    # 1) Заголовок auditd: type=XXX msg=audit(epoch:serial): <msg>
    #
    grok {
      match => {
        "message" => [
          "type=%{WORD:auditd.type}\s+msg=audit\(%{NUMBER:auditd.epoch}(?:\.%{NUMBER:auditd.msec})?:%{NUMBER:auditd.serial}\):\s+%{GREEDYDATA:auditd.msg}"
        ]
      }
      tag_on_failure => [ "_grokparsefailure_auditd" ]
    }
    
    if "firefox" in [message] or "chromium" in [message] or "/proc/pressure/memory" in [message] {
      drop { }
    }

    #
    # 2) Дополнительный grok по твоему шаблону (SYSCALL / USER / PATH / EXECVE)
    #
    grok {
      match => {
        "message" => [

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): .* syscall=%{DATA:auditd.syscall} success=%{DATA:event.result} exit=%{DATA:auditd.exit} .* .* .* .* .* ppid=%{NUMBER:process.ppid} pid=%{NUMBER:process.pid} auid=%{NUMBER:user.auid} uid=%{NUMBER:user.uid} .* .* suid=%{NUMBER:user.suid} .* .* .* .* .* .* comm=%{DATA:process.name} exe=%{DATA:process.executable} (%{GREEDYDATA})?",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): %{GREEDYDATA} acct=\"%{DATA:user.name}\" %{GREEDYDATA} addr=%{IPORHOST:source.ip} %{GREEDYDATA} res=%{WORD:event.result}(\')?",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): (%{GREEDYDATA})?(a0=\"%{DATA:auditd.a0}\" a1=\"%{DATA:auditd.a1}\" a2=\"%{DATA:auditd.a2}\" a3=\"%{DATA:auditd.a3}\" a4=\"%{DATA:auditd.a4}\"|a0=\"%{DATA:auditd.a0}\" a1=\"%{DATA:auditd.a1}\" a2=\"%{DATA:auditd.a2}\" a3=\"%{DATA:auditd.a3}\"|a0=\"%{DATA:auditd.a0}\" a1=\"%{DATA:auditd.a1}\" a2=\"%{DATA:auditd.a2}\"|a0=\"%{DATA:auditd.a0}\" a1=\"%{DATA:auditd.a1}\" a2=\"%{DATA:auditd.a2}\"|a0=\"%{DATA:auditd.a0}\" a1=\"%{DATA:auditd.a1}\"|a0=\"%{DATA:auditd.a0}\")",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): (%{GREEDYDATA})?a0=%{WORD:auditd.a0} %{GREEDYDATA} items=%{NUMBER:auditd.items} ppid=%{NUMBER:process.ppid} pid=%{NUMBER:process.pid} %{GREEDYDATA}",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): %{GREEDYDATA} acct=\"%{DATA:user.name}\" %{GREEDYDATA} res=%{WORD:event.result}(\')?",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): %{GREEDYDATA} res=%{WORD:event.result}(\')?",

          "type=%{WORD:auditd.type} msg=audit\(%{NUMBER:auditd.epoch}:%{NUMBER:auditd.serial}\): item=%{NUMBER:auditd.item} name=%{DATA:auditd.path.name} %{GREEDYDATA}"
        ]
      }
      tag_on_failure => [ "_grokparsefailure_auditd_extra" ]
    }

    #
    # 3) kv по auditd.msg — добираем оставшиеся key=value
    #
    kv {
      source          => "auditd.msg"
      field_split     => " "
      value_split     => "="
      trim_key        => "\"'"
      trim_value      => "\"'"
    }

    #
    # 4) Декодируем PROCTITLE (hex или строка) в proctitle/process.command_line
    #
    ruby {
      code => '
        if event.get("auditd.type") == "PROCTITLE"
          raw = event.get("auditd.msg")
          if raw
            begin
              value = raw.sub(/^proctitle=/, "")
              value = value.gsub(/\A"+|"+\Z/, "")

              if value =~ /\A[0-9A-Fa-f]+\z/
                str = [value].pack("H*")
                str = str.gsub("\x00", " ").strip
              else
                str = value
              end

              event.set("proctitle", str)
              event.set("[process][command_line]", str)
            rescue => e
              event.tag("proctitle_decode_error")
            end
          end
        end
      '
    }

    #
    # 5) Нормализуем поля
    #
    mutate {
      rename => {
        "uid"      => "user.uid"
        "auid"     => "user.auid"
        "pid"      => "process.pid"
        "ppid"     => "process.ppid"
        "exe"      => "process.executable"
        "comm"     => "process.name"
        "ses"      => "session.id"
        "res"      => "event.result"
        "addr"     => "source.ip"
        "hostname" => "source.hostname"
        "terminal" => "process.terminal"
        "msg"      => "auditd.inner_msg"
        "key"      => "auditd.key"
        "name"     => "auditd.path.name"
        "nametype" => "auditd.path.nametype"
      }

      convert => {
        "user.uid"      => "integer"
        "user.auid"     => "integer"
        "process.pid"   => "integer"
        "process.ppid"  => "integer"
        "session.id"    => "integer"
      }

      add_field => {
        "event.category" => "process"
        "event.module"   => "auditd"
        "event.action"   => "%{auditd.type}"
        "app"            => "system"
        "[@metadata][target_index]" => "system-audit"
      }

      remove_field => [ "host", "agent", "ecs", "input", "@version" ]
    }

    #
    # 6) event.outcome
    #
    if [event.result] == "success" {
      mutate { add_field => { "event.outcome" => "success" } }
    } else if [event.result] == "failed" or [event.result] == "fail" {
      mutate { add_field => { "event.outcome" => "failure" } }
    }

    #
    # 7) file.* для PATH
    #
    if [auditd.type] == "PATH" {
      mutate {
        add_field => {
          "[file][path]"     => "%{auditd.path.name}"
          "[file][nametype]" => "%{auditd.path.nametype}"
        }
      }
    }
  }

  ################ ВСЁ, ЧТО НЕ ПОДОШЛО ################
  else {
    mutate {
      add_field => { "[@metadata][target_index]" => "unknown-logs" }
    }
  }
}

########## OUTPUT ##########

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"          # можно сделать отдельного пользователя, но для стенда хватит elastic
    password => "haRRy564"     # тот пароль, который ты задал командой elasticsearch-setup-passwords
    index => "%{[@metadata][target_index]}-%{+YYYY.MM.dd}"
  }

  stdout {
    codec => rubydebug
  }
}
